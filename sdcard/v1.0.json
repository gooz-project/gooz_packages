{
    "name": "sdcard",
    "codes": [
        {
            "filename": "main.py",
            "code": "import os, utime, _threadpkglineflagfrom machine import Pin, SoftSPIpkglineflagfrom app.sdcard.sdcardlib import SDCardpkglineflagfrom engine.engine_template import EngineTemplatepkglineflagfrom wifuxlogger import WifuxLogger as LOGpkglineflagimport ujsonpkglineflagpkglineflagdef run(cmds):pkglineflag    if not len(cmds)>1:pkglineflag        LOG.error(\"Please enter a command!\")pkglineflag        LOG.info(\"You can use 'sdcard help' for available commands!\")pkglineflag        returnpkglineflag    if cmds[1][0] == '_':pkglineflag        returnpkglineflag    exec(f'{cmds[1]}({cmds})')pkglineflagpkglineflagdef help(cmds):pkglineflag    command_list =['register','delete','update','mount','umount','show']pkglineflag    print('---- SD Card Package for Gooz Os ---')pkglineflag    print('-Version: 1.0')pkglineflag    print('-Available Commands:')pkglineflag    for command in command_list:pkglineflag        print(\"\\t-\"+command)pkglineflag    print('Visit GitHub Page for Usage of Commands:')pkglineflag    print('https://github.com/gooz-project/gooz_packages/tree/main/sdcard')pkglineflagpkglineflagdef register(cmds):pkglineflag    blueprint={\"--name\":\"\",\"--miso\":\"\",\"--mosi\":\"\",\"--sck\":\"\",\"--cs\":\"\"}pkglineflag    missing_arg = Falsepkglineflag    blueprint = EngineTemplate.parameter_parser(cmds,blueprint)pkglineflag    for key in blueprint:pkglineflag        if blueprint[key] == \"\":pkglineflag            missing_arg = Truepkglineflag            breakpkglineflag    if missing_arg:pkglineflag        LOG.error(\"Missing Argument(s)\")pkglineflag        returnpkglineflag    registered = _returnerload(cmds)pkglineflag    registered.append(blueprint)pkglineflag    f = open('app/sdcard/sdconfig.json','w')pkglineflag    ujson.dump(registered,f)pkglineflag    f.close()pkglineflag    pkglineflagdef _returnerload(cmds):pkglineflag    payload = \"\"pkglineflag    try:pkglineflag        with open(\"app/sdcard/sdconfig.json\", \"r\") as fp:pkglineflag            payload = fp.read()pkglineflag            fp.close()pkglineflag    except OSError:pkglineflag        with open(\"app/sdcard/sdconfig.json\",\"w\") as fp:pkglineflag            fp.write('[]')pkglineflag            fp.closepkglineflag    if payload=='':pkglineflag        payload='[]'pkglineflag    payload = ujson.loads(payload)pkglineflag    return payloadpkglineflagpkglineflagdef show(cmds):pkglineflag    payload = \"\"pkglineflag    try:pkglineflag        with open(\"/app/sdcard/sdconfig.json\", \"r\") as fp:pkglineflag            payload = fp.read()pkglineflag            fp.close()pkglineflag        payload = ujson.loads(payload)pkglineflag        for i in payload:pkglineflag            LOG.info(i)pkglineflag    except OSError:pkglineflag        LOG.error(\"There is no registered SD card!\")pkglineflag    pkglineflagdef delete(cmds):pkglineflag    name = cmds[2]pkglineflag    payload = _returnerload(cmds)pkglineflag    founded = Falsepkglineflag    with open(\"app/sdcard/sdconfig.json\",'w') as fp:  pkglineflag        for pin in payload:pkglineflag            if pin[\"--name\"] == name:pkglineflag                payload.remove(pin)pkglineflag                founded = Truepkglineflag        ujson.dump(payload,fp)pkglineflag        fp.close()pkglineflag    if founded:pkglineflag        LOG.debug(f'The sd card named \"{name}\" is deleted')pkglineflag    else:pkglineflag        LOG.error(f'There is no SD card named \"{name}\" !')pkglineflagpkglineflagdef update(cmds):pkglineflag    name = cmds[2]pkglineflag    payload = _returnerload(cmds)pkglineflag    blueprint={}pkglineflag    founded = Falsepkglineflag    for pin in payload:pkglineflag        if pin[\"--name\"] == name:pkglineflag            blueprint = pinpkglineflag            delete(cmds)pkglineflag            founded = Truepkglineflag            breakpkglineflag    if blueprint == {}:pkglineflag        returnpkglineflag    blueprint = EngineTemplate.parameter_parser(cmds,blueprint)pkglineflag    payload = _returnerload(cmds)pkglineflag    payload.append(blueprint)pkglineflag    with open(\"app/sdcard/sdconfig.json\", \"w\") as fp:pkglineflag        ujson.dump(payload,fp)pkglineflag        fp.close()pkglineflag    if founded:pkglineflag        LOG.debug(f'SD card parameters \"{name}\" are updated')pkglineflag    else:pkglineflag        LOG.error(f'There is no SD card named \"{name}\" !')pkglineflagpkglineflagdef mount(cmds):pkglineflag    if not len(cmds) >2:pkglineflag        LOG.error(\"Missing Argument(s)\\nPlease check name of Sd card\")pkglineflag        returnpkglineflag    name = cmds[2]pkglineflag    payload = _returnerload(cmds)pkglineflag    founded = Falsepkglineflag    for mySD in payload:pkglineflag        if mySD[\"--name\"] == name:pkglineflag            spisd = SoftSPI(miso=Pin(int(mySD[\"--miso\"])), mosi=Pin(int(mySD[\"--mosi\"])), sck=Pin(int(mySD[\"--sck\"])))pkglineflag            sd = SDCard(spisd, Pin(int(mySD[\"--cs\"])))pkglineflag            vfs = os.VfsFat(sd)pkglineflag            if len(cmds) == 3 and not 'as' in cmds:pkglineflag                os.mount(vfs, f'/{mySD[\"--name\"]}')   pkglineflag                LOG.debug(\"Files in SD card: \"+str(os.listdir(f'/{mySD[\"--name\"]}'))  )    pkglineflag            elif len(cmds) > 3 and 'as' in cmds:pkglineflag                file_name_list = cmds[cmds.index('as')+1:]pkglineflag                file_name=''pkglineflag                for c in file_name_list:pkglineflag                    file_name += cpkglineflag                os.mount(vfs,f'/{file_name}')pkglineflag                LOG.debug(\"Files in SD card: \"+str(os.listdir(f'/{file_name}')))pkglineflag            founded = Truepkglineflag    if not founded:pkglineflag        LOG.error(f'There is no SD card named \"{name}\" !')pkglineflag            pkglineflagdef umount(cmds):pkglineflag    if not len(cmds) >2:pkglineflag        LOG.error(\"Missing Argument(s)\\nPlease check name of Sd card\")pkglineflag        returnpkglineflag    os.umount(f'/{cmds[2]}')"
        },
        {
            "filename": "sdcardlib.py",
            "code": "from micropython import constpkglineflagimport timepkglineflagpkglineflag_CMD_TIMEOUT = const(100)pkglineflagpkglineflag_R1_IDLE_STATE = const(1 << 0)pkglineflag_R1_ILLEGAL_COMMAND = const(1 << 2)pkglineflag_TOKEN_CMD25 = const(0xFC)pkglineflag_TOKEN_STOP_TRAN = const(0xFD)pkglineflag_TOKEN_DATA = const(0xFE)pkglineflagpkglineflagclass SDCard:pkglineflag    def __init__(self, spi, cs, baudrate=1320000):pkglineflag        self.spi = spipkglineflag        self.cs = cspkglineflagpkglineflag        self.cmdbuf = bytearray(6)pkglineflag        self.dummybuf = bytearray(512)pkglineflag        self.tokenbuf = bytearray(1)pkglineflag        for i in range(512):pkglineflag            self.dummybuf[i] = 0xFFpkglineflag        self.dummybuf_memoryview = memoryview(self.dummybuf)pkglineflagpkglineflag        self.init_card(baudrate)pkglineflagpkglineflag    def init_spi(self, baudrate):pkglineflag        try:pkglineflag            master = self.spi.MASTERpkglineflag        except AttributeError:pkglineflag            self.spi.init(baudrate=baudrate, phase=0, polarity=0)pkglineflag        else:pkglineflag            self.spi.init(master, baudrate=baudrate, phase=0, polarity=0)pkglineflagpkglineflag    def init_card(self, baudrate):pkglineflagpkglineflag        self.cs.init(self.cs.OUT, value=1)pkglineflag        self.init_spi(100000)pkglineflag        for i in range(16):pkglineflag            self.spi.write(b\"\\xff\")pkglineflag        for _ in range(5):pkglineflag            if self.cmd(0, 0, 0x95) == _R1_IDLE_STATE:pkglineflag                breakpkglineflag        else:pkglineflag            raise OSError(\"no SD card\")pkglineflagpkglineflag        r = self.cmd(8, 0x01AA, 0x87, 4)pkglineflag        if r == _R1_IDLE_STATE:pkglineflag            self.init_card_v2()pkglineflag        elif r == (_R1_IDLE_STATE | _R1_ILLEGAL_COMMAND):pkglineflag            self.init_card_v1()pkglineflag        else:pkglineflag            raise OSError(\"couldn't determine SD card version\")pkglineflagpkglineflag        if self.cmd(9, 0, 0, 0, False) != 0:pkglineflag            raise OSError(\"no response from SD card\")pkglineflag        csd = bytearray(16)pkglineflag        self.readinto(csd)pkglineflag        if csd[0] & 0xC0 == 0x40:pkglineflag            self.sectors = ((csd[8] << 8 | csd[9]) + 1) * 1024pkglineflag        elif csd[0] & 0xC0 == 0x00:pkglineflag            c_size = csd[6] & 0b11 | csd[7] << 2 | (csd[8] & 0b11000000) << 4pkglineflag            c_size_mult = ((csd[9] & 0b11) << 1) | csd[10] >> 7pkglineflag            self.sectors = (c_size + 1) * (2 ** (c_size_mult + 2))pkglineflag        else:pkglineflag            raise OSError(\"SD card CSD format not supported\")pkglineflag        if self.cmd(16, 512, 0) != 0:pkglineflag            raise OSError(\"can't set 512 block size\")pkglineflag        self.init_spi(baudrate)pkglineflagpkglineflag    def init_card_v1(self):pkglineflag        for i in range(_CMD_TIMEOUT):pkglineflag            self.cmd(55, 0, 0)pkglineflag            if self.cmd(41, 0, 0) == 0:pkglineflag                self.cdv = 512pkglineflag                returnpkglineflag        raise OSError(\"timeout waiting for v1 card\")pkglineflagpkglineflag    def init_card_v2(self):pkglineflag        for i in range(_CMD_TIMEOUT):pkglineflag            time.sleep_ms(50)pkglineflag            self.cmd(58, 0, 0, 4)pkglineflag            self.cmd(55, 0, 0)pkglineflag            if self.cmd(41, 0x40000000, 0) == 0:pkglineflag                self.cmd(58, 0, 0, 4)pkglineflag                self.cdv = 1pkglineflag                returnpkglineflag        raise OSError(\"timeout waiting for v2 card\")pkglineflagpkglineflag    def cmd(self, cmd, arg, crc, final=0, release=True, skip1=False):pkglineflag        self.cs(0)pkglineflag        buf = self.cmdbufpkglineflag        buf[0] = 0x40 | cmdpkglineflag        buf[1] = arg >> 24pkglineflag        buf[2] = arg >> 16pkglineflag        buf[3] = arg >> 8pkglineflag        buf[4] = argpkglineflag        buf[5] = crcpkglineflag        self.spi.write(buf)pkglineflagpkglineflag        if skip1:pkglineflag            self.spi.readinto(self.tokenbuf, 0xFF)pkglineflagpkglineflag        for i in range(_CMD_TIMEOUT):pkglineflag            self.spi.readinto(self.tokenbuf, 0xFF)pkglineflag            response = self.tokenbuf[0]pkglineflag            if not (response & 0x80):pkglineflag                for j in range(final):pkglineflag                    self.spi.write(b\"\\xff\")pkglineflag                if release:pkglineflag                    self.cs(1)pkglineflag                    self.spi.write(b\"\\xff\")pkglineflag                return responsepkglineflag        self.cs(1)pkglineflag        self.spi.write(b\"\\xff\")pkglineflag        return -1pkglineflagpkglineflag    def readinto(self, buf):pkglineflag        self.cs(0)pkglineflag        for i in range(_CMD_TIMEOUT):pkglineflag            self.spi.readinto(self.tokenbuf, 0xFF)pkglineflag            if self.tokenbuf[0] == _TOKEN_DATA:pkglineflag                breakpkglineflag            time.sleep_ms(1)pkglineflag        else:pkglineflag            self.cs(1)pkglineflag            raise OSError(\"timeout waiting for response\")pkglineflagpkglineflag        mv = self.dummybuf_memoryviewpkglineflag        if len(buf) != len(mv):pkglineflag            mv = mv[: len(buf)]pkglineflag        self.spi.write_readinto(mv, buf)pkglineflag        self.spi.write(b\"\\xff\")pkglineflag        self.spi.write(b\"\\xff\")pkglineflagpkglineflag        self.cs(1)pkglineflag        self.spi.write(b\"\\xff\")pkglineflagpkglineflag    def write(self, token, buf):pkglineflag        self.cs(0)pkglineflag        self.spi.read(1, token)pkglineflag        self.spi.write(buf)pkglineflag        self.spi.write(b\"\\xff\")pkglineflag        self.spi.write(b\"\\xff\")pkglineflag        if (self.spi.read(1, 0xFF)[0] & 0x1F) != 0x05:pkglineflag            self.cs(1)pkglineflag            self.spi.write(b\"\\xff\")pkglineflag            returnpkglineflagpkglineflag        while self.spi.read(1, 0xFF)[0] == 0:pkglineflag            passpkglineflagpkglineflag        self.cs(1)pkglineflag        self.spi.write(b\"\\xff\")pkglineflagpkglineflag    def write_token(self, token):pkglineflag        self.cs(0)pkglineflag        self.spi.read(1, token)pkglineflag        self.spi.write(b\"\\xff\")pkglineflag        while self.spi.read(1, 0xFF)[0] == 0x00:pkglineflag            passpkglineflagpkglineflag        self.cs(1)pkglineflag        self.spi.write(b\"\\xff\")pkglineflagpkglineflag    def readblocks(self, block_num, buf):pkglineflag        nblocks = len(buf) // 512pkglineflag        assert nblocks and not len(buf) % 512, \"Buffer length is invalid\"pkglineflag        if nblocks == 1:pkglineflag            if self.cmd(17, block_num * self.cdv, 0, release=False) != 0:pkglineflag                self.cs(1)pkglineflag                raise OSError(5)pkglineflag            self.readinto(buf)pkglineflag        else:pkglineflag            if self.cmd(18, block_num * self.cdv, 0, release=False) != 0:pkglineflag                self.cs(1)pkglineflag                raise OSError(5)  # EIOpkglineflag            offset = 0pkglineflag            mv = memoryview(buf)pkglineflag            while nblocks:pkglineflag                self.readinto(mv[offset : offset + 512])pkglineflag                offset += 512pkglineflag                nblocks -= 1pkglineflag            if self.cmd(12, 0, 0xFF, skip1=True):pkglineflag                raise OSError(5)pkglineflagpkglineflag    def writeblocks(self, block_num, buf):pkglineflag        nblocks, err = divmod(len(buf), 512)pkglineflag        assert nblocks and not err, \"Buffer length is invalid\"pkglineflag        if nblocks == 1:pkglineflag            if self.cmd(24, block_num * self.cdv, 0) != 0:pkglineflag                raise OSError(5)pkglineflag            self.write(_TOKEN_DATA, buf)pkglineflag        else:pkglineflag            if self.cmd(25, block_num * self.cdv, 0) != 0:pkglineflag                raise OSError(5)pkglineflag            offset = 0pkglineflag            mv = memoryview(buf)pkglineflag            while nblocks:pkglineflag                self.write(_TOKEN_CMD25, mv[offset : offset + 512])pkglineflag                offset += 512pkglineflag                nblocks -= 1pkglineflag            self.write_token(_TOKEN_STOP_TRAN)pkglineflagpkglineflag    def ioctl(self, op, arg):pkglineflag        if op == 4:pkglineflag            return self.sectorspkglineflag"
        }
    ]
}
