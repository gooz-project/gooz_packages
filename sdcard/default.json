{
    "name": "sdcard",
    "codes": [
        {
            "filename": "main.py",
            "code": "import os, utime, _threadpkglineflagfrom machine import Pin, SoftSPIpkglineflagfrom app.sdcard.sdcardlib import SDCardpkglineflagfrom engine.engine_template import EngineTemplatepkglineflagfrom wifuxlogger import WifuxLogger as LOGpkglineflagfrom dev.pin.core import CommonCommands as PinCommandspkglineflagimport ujsonpkglineflagpkglineflagconfig_path = '//app/sdcard/sdconfig.json'pkglineflagclass SDCardErrors():pkglineflag    pkglineflag    @staticmethodpkglineflag    def undefined_pin_name(pin_name):pkglineflag        return LOG.error(f'There is no sdcard pin named \"{pin_name}\" !')pkglineflag    pkglineflag    @staticmethodpkglineflag    def var_usage():pkglineflag        return LOG.info('\\nUsage:\\nsdcard var --name [SDCARD_PIN_NAME] --miso [SDCARD_MISO_PIN] --mosi [SDCARD_MOSI_PIN] --sck [SDCARD_SCK_PIN] --cs [SDCARD_CS_PIN]')pkglineflag    pkglineflag    @staticmethodpkglineflag    def mount_usage():pkglineflag        return LOG.info(\"\"\"pkglineflagUsage -> sdcard mount [SDCARD_PIN_NAME]pkglineflagAn folder named [SDCARD_PIN_NAME] will be createdpkglineflagUsage -> sdcard mount [SDCARD_PIN_NAME] as [FOLDER_NAME]pkglineflagAn file named [FOLDER_NAME] will be created\"\"\")pkglineflag    pkglineflag    @staticmethod   pkglineflag    def umount_usage():pkglineflag        return LOG.info(\"\"\"pkglineflagUsage -> sdcard umount [FOLDER_NAME]pkglineflagIt must be name of folder, not the name of sdcard pin!pkglineflagsdcard measure command simply measures current temperature and humidity\"\"\")pkglineflag    pkglineflag    @staticmethodpkglineflag    def delete_usage():pkglineflag        return LOG.info('\\nUsage -> sdcard delete [SDCARD_PIN_NAME]\\nsdcard delete command deletes registered sdcard pins by [SDCARD_PIN_NAME]')pkglineflagpkglineflag    @staticmethodpkglineflag    def show_usage():pkglineflag        return LOG.info(\"\"\"pkglineflagUsage -> sdcard showpkglineflagsdcard show command simply prints registered sdcard pinspkglineflagUsage -> sdcard show search_key:search_value\"\"\")pkglineflagpkglineflagdef help(cmds):pkglineflag    command_list = ['var','show','delete','update','mount','umount']pkglineflag    commands = '\\n'.join(command_list)pkglineflag    if not len(cmds) > 2:pkglineflag        return LOG.info(\"\"\"pkglineflag---- SD Card Package for Gooz Os ---pkglineflagVersion: 3.0pkglineflagVisit GitHub Page for More Details:pkglineflaghttps://github.com/gooz-project/gooz_packages/tree/main/sdcardpkglineflagCommands:pkglineflag\"\"\"+commands)pkglineflag    try:pkglineflag        return eval('SDCardErrors.{}_usage()'.format(cmds[2]))pkglineflag    except:pkglineflag        return LOG.error('There is no help for \"{}\"!'.format(cmds[2]))pkglineflagpkglineflagdef run(cmds):pkglineflag    if not len(cmds)>1:pkglineflag        return LOG.error(\"Please enter a command!\") + LOG.info(\"You can use 'sdcard help' for available commands!\")pkglineflag    if cmds[1][0] == '_':pkglineflag        return LOG.error('There is no command!')pkglineflag    return eval('{}({})'.format(cmds[1], cmds))pkglineflag    pkglineflagdef var(cmds):pkglineflag    blueprint={\"pinType\":\"sdcard\",\"--name\":\"\",\"--miso\":\"\",\"--mosi\":\"\",\"--sck\":\"\",\"--cs\":\"\"}pkglineflag    temp = EngineTemplate.parameter_parser(cmds,blueprint)pkglineflag    missing = Falsepkglineflag    for key in temp:pkglineflag        if temp[key] == \"\":pkglineflag            missing=Truepkglineflag            return LOG.error('Error while registering sdcard pin!\\nMissing Argument(s)!') + SDCardErrors.var_usage()            pkglineflag            breakpkglineflag    if missing:pkglineflag        returnpkglineflag    blueprint = PinCommands(cmds, path=config_path,pin_type=\"sdcard\").register(blueprint)pkglineflag    if blueprint:   pkglineflag        return LOG.info('The new sdcard pin named \"{}\" successfully saved:\\n{}'.format(blueprint[\"--name\"],blueprint))pkglineflag    del blueprintpkglineflag    pkglineflagpkglineflagdef show(cmds):pkglineflag    return PinCommands(cmds,path=config_path,pin_type=\"sdcard\").show()pkglineflag    pkglineflagdef delete(cmds):pkglineflag    try: pkglineflag        founded = PinCommands(cmds,config_path,pin_type=\"sdcard\",pin_name=cmds[2]).delete()pkglineflag        if founded:pkglineflag            return LOG.debug('The sdcard pin named \"{}\" successfully deleted.'.format(cmds[2]))pkglineflag        else:pkglineflag            return SDCardErrors.undefined_pin_name()pkglineflag    except IndexError:pkglineflag        return LOG.error(\"Missing arg(s)\") + SDCardErrors.delete_usage()pkglineflag        pkglineflagpkglineflagdef update(cmds):pkglineflag    return PinCommands(cmds,config_path,pin_type=\"sdcard\",pin_name=cmds[2]).update()pkglineflagpkglineflagdef mount(cmds):pkglineflag    if not len(cmds) >2:pkglineflag        return LOG.error(\"Missing Argument(s)\\nPlease check name of Sd card\")pkglineflag    name = cmds[2]pkglineflag    mySD = PinCommands(cmds,path=config_path).get_pin(\"sdcard\",name)pkglineflag    spisd = SoftSPI(miso=Pin(int(mySD[\"--miso\"])), mosi=Pin(int(mySD[\"--mosi\"])), sck=Pin(int(mySD[\"--sck\"])))pkglineflag    sd = SDCard(spisd, Pin(int(mySD[\"--cs\"])))pkglineflag    vfs = os.VfsFat(sd)pkglineflag    if len(cmds) == 3 and not 'as' in cmds:pkglineflag        os.mount(vfs, '/{}'.format(mySD['--name']))   pkglineflag        return LOG.debug(\"Files in SD card: \"+str(os.listdir('/{}'.format(mySD['--name'])))  )    pkglineflag    elif len(cmds) > 3 and 'as' in cmds:pkglineflag        file_name_list = cmds[cmds.index('as')+1:]pkglineflag        file_name=''pkglineflag        for c in file_name_list:pkglineflag            file_name += cpkglineflag        os.mount(vfs,'/{}'.format(file_name))pkglineflag        return LOG.debug(\"Files in SD card: \"+str(os.listdir('/{}'.format(file_name))))pkglineflag    founded = Truepkglineflag    if not founded:pkglineflag        return LOG.error('There is no SD card named \"{}\" !'.format(name))pkglineflag            pkglineflagdef umount(cmds):pkglineflag    if not len(cmds) >2:pkglineflag        return LOG.error(\"Missing Argument(s)\\nPlease check name of Sd card\")pkglineflag    os.umount('/{}'.format(cmds[2]))pkglineflag    return LOG.info('Sdcard is umounted')"
        },
        {
            "filename": "sdcardlib.py",
            "code": "from micropython import constpkglineflagimport timepkglineflagpkglineflag_CMD_TIMEOUT = const(100)pkglineflagpkglineflag_R1_IDLE_STATE = const(1 << 0)pkglineflag_R1_ILLEGAL_COMMAND = const(1 << 2)pkglineflag_TOKEN_CMD25 = const(0xFC)pkglineflag_TOKEN_STOP_TRAN = const(0xFD)pkglineflag_TOKEN_DATA = const(0xFE)pkglineflagpkglineflagclass SDCard:pkglineflag    def __init__(self, spi, cs, baudrate=1320000):pkglineflag        self.spi = spipkglineflag        self.cs = cspkglineflagpkglineflag        self.cmdbuf = bytearray(6)pkglineflag        self.dummybuf = bytearray(512)pkglineflag        self.tokenbuf = bytearray(1)pkglineflag        for i in range(512):pkglineflag            self.dummybuf[i] = 0xFFpkglineflag        self.dummybuf_memoryview = memoryview(self.dummybuf)pkglineflagpkglineflag        self.init_card(baudrate)pkglineflagpkglineflag    def init_spi(self, baudrate):pkglineflag        try:pkglineflag            master = self.spi.MASTERpkglineflag        except AttributeError:pkglineflag            self.spi.init(baudrate=baudrate, phase=0, polarity=0)pkglineflag        else:pkglineflag            self.spi.init(master, baudrate=baudrate, phase=0, polarity=0)pkglineflagpkglineflag    def init_card(self, baudrate):pkglineflagpkglineflag        self.cs.init(self.cs.OUT, value=1)pkglineflag        self.init_spi(100000)pkglineflag        for i in range(16):pkglineflag            self.spi.write(b\"\\xff\")pkglineflag        for _ in range(5):pkglineflag            if self.cmd(0, 0, 0x95) == _R1_IDLE_STATE:pkglineflag                breakpkglineflag        else:pkglineflag            raise OSError(\"no SD card\")pkglineflagpkglineflag        r = self.cmd(8, 0x01AA, 0x87, 4)pkglineflag        if r == _R1_IDLE_STATE:pkglineflag            self.init_card_v2()pkglineflag        elif r == (_R1_IDLE_STATE | _R1_ILLEGAL_COMMAND):pkglineflag            self.init_card_v1()pkglineflag        else:pkglineflag            raise OSError(\"couldn't determine SD card version\")pkglineflagpkglineflag        if self.cmd(9, 0, 0, 0, False) != 0:pkglineflag            raise OSError(\"no response from SD card\")pkglineflag        csd = bytearray(16)pkglineflag        self.readinto(csd)pkglineflag        if csd[0] & 0xC0 == 0x40:pkglineflag            self.sectors = ((csd[8] << 8 | csd[9]) + 1) * 1024pkglineflag        elif csd[0] & 0xC0 == 0x00:pkglineflag            c_size = csd[6] & 0b11 | csd[7] << 2 | (csd[8] & 0b11000000) << 4pkglineflag            c_size_mult = ((csd[9] & 0b11) << 1) | csd[10] >> 7pkglineflag            self.sectors = (c_size + 1) * (2 ** (c_size_mult + 2))pkglineflag        else:pkglineflag            raise OSError(\"SD card CSD format not supported\")pkglineflag        if self.cmd(16, 512, 0) != 0:pkglineflag            raise OSError(\"can't set 512 block size\")pkglineflag        self.init_spi(baudrate)pkglineflagpkglineflag    def init_card_v1(self):pkglineflag        for i in range(_CMD_TIMEOUT):pkglineflag            self.cmd(55, 0, 0)pkglineflag            if self.cmd(41, 0, 0) == 0:pkglineflag                self.cdv = 512pkglineflag                returnpkglineflag        raise OSError(\"timeout waiting for v1 card\")pkglineflagpkglineflag    def init_card_v2(self):pkglineflag        for i in range(_CMD_TIMEOUT):pkglineflag            time.sleep_ms(50)pkglineflag            self.cmd(58, 0, 0, 4)pkglineflag            self.cmd(55, 0, 0)pkglineflag            if self.cmd(41, 0x40000000, 0) == 0:pkglineflag                self.cmd(58, 0, 0, 4)pkglineflag                self.cdv = 1pkglineflag                returnpkglineflag        raise OSError(\"timeout waiting for v2 card\")pkglineflagpkglineflag    def cmd(self, cmd, arg, crc, final=0, release=True, skip1=False):pkglineflag        self.cs(0)pkglineflag        buf = self.cmdbufpkglineflag        buf[0] = 0x40 | cmdpkglineflag        buf[1] = arg >> 24pkglineflag        buf[2] = arg >> 16pkglineflag        buf[3] = arg >> 8pkglineflag        buf[4] = argpkglineflag        buf[5] = crcpkglineflag        self.spi.write(buf)pkglineflagpkglineflag        if skip1:pkglineflag            self.spi.readinto(self.tokenbuf, 0xFF)pkglineflagpkglineflag        for i in range(_CMD_TIMEOUT):pkglineflag            self.spi.readinto(self.tokenbuf, 0xFF)pkglineflag            response = self.tokenbuf[0]pkglineflag            if not (response & 0x80):pkglineflag                for j in range(final):pkglineflag                    self.spi.write(b\"\\xff\")pkglineflag                if release:pkglineflag                    self.cs(1)pkglineflag                    self.spi.write(b\"\\xff\")pkglineflag                return responsepkglineflag        self.cs(1)pkglineflag        self.spi.write(b\"\\xff\")pkglineflag        return -1pkglineflagpkglineflag    def readinto(self, buf):pkglineflag        self.cs(0)pkglineflag        for i in range(_CMD_TIMEOUT):pkglineflag            self.spi.readinto(self.tokenbuf, 0xFF)pkglineflag            if self.tokenbuf[0] == _TOKEN_DATA:pkglineflag                breakpkglineflag            time.sleep_ms(1)pkglineflag        else:pkglineflag            self.cs(1)pkglineflag            raise OSError(\"timeout waiting for response\")pkglineflagpkglineflag        mv = self.dummybuf_memoryviewpkglineflag        if len(buf) != len(mv):pkglineflag            mv = mv[: len(buf)]pkglineflag        self.spi.write_readinto(mv, buf)pkglineflag        self.spi.write(b\"\\xff\")pkglineflag        self.spi.write(b\"\\xff\")pkglineflagpkglineflag        self.cs(1)pkglineflag        self.spi.write(b\"\\xff\")pkglineflagpkglineflag    def write(self, token, buf):pkglineflag        self.cs(0)pkglineflag        self.spi.read(1, token)pkglineflag        self.spi.write(buf)pkglineflag        self.spi.write(b\"\\xff\")pkglineflag        self.spi.write(b\"\\xff\")pkglineflag        if (self.spi.read(1, 0xFF)[0] & 0x1F) != 0x05:pkglineflag            self.cs(1)pkglineflag            self.spi.write(b\"\\xff\")pkglineflag            returnpkglineflagpkglineflag        while self.spi.read(1, 0xFF)[0] == 0:pkglineflag            passpkglineflagpkglineflag        self.cs(1)pkglineflag        self.spi.write(b\"\\xff\")pkglineflagpkglineflag    def write_token(self, token):pkglineflag        self.cs(0)pkglineflag        self.spi.read(1, token)pkglineflag        self.spi.write(b\"\\xff\")pkglineflag        while self.spi.read(1, 0xFF)[0] == 0x00:pkglineflag            passpkglineflagpkglineflag        self.cs(1)pkglineflag        self.spi.write(b\"\\xff\")pkglineflagpkglineflag    def readblocks(self, block_num, buf):pkglineflag        nblocks = len(buf) // 512pkglineflag        assert nblocks and not len(buf) % 512, \"Buffer length is invalid\"pkglineflag        if nblocks == 1:pkglineflag            if self.cmd(17, block_num * self.cdv, 0, release=False) != 0:pkglineflag                self.cs(1)pkglineflag                raise OSError(5)pkglineflag            self.readinto(buf)pkglineflag        else:pkglineflag            if self.cmd(18, block_num * self.cdv, 0, release=False) != 0:pkglineflag                self.cs(1)pkglineflag                raise OSError(5)  # EIOpkglineflag            offset = 0pkglineflag            mv = memoryview(buf)pkglineflag            while nblocks:pkglineflag                self.readinto(mv[offset : offset + 512])pkglineflag                offset += 512pkglineflag                nblocks -= 1pkglineflag            if self.cmd(12, 0, 0xFF, skip1=True):pkglineflag                raise OSError(5)pkglineflagpkglineflag    def writeblocks(self, block_num, buf):pkglineflag        nblocks, err = divmod(len(buf), 512)pkglineflag        assert nblocks and not err, \"Buffer length is invalid\"pkglineflag        if nblocks == 1:pkglineflag            if self.cmd(24, block_num * self.cdv, 0) != 0:pkglineflag                raise OSError(5)pkglineflag            self.write(_TOKEN_DATA, buf)pkglineflag        else:pkglineflag            if self.cmd(25, block_num * self.cdv, 0) != 0:pkglineflag                raise OSError(5)pkglineflag            offset = 0pkglineflag            mv = memoryview(buf)pkglineflag            while nblocks:pkglineflag                self.write(_TOKEN_CMD25, mv[offset : offset + 512])pkglineflag                offset += 512pkglineflag                nblocks -= 1pkglineflag            self.write_token(_TOKEN_STOP_TRAN)pkglineflagpkglineflag    def ioctl(self, op, arg):pkglineflag        if op == 4:pkglineflag            return self.sectorspkglineflag"
        }
    ]
}