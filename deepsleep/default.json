{
    "name": "deepsleep",
    "codes": [
        {
            "filename": "deepsleepconfig.json",
            "code": "[]"
        },
        {
            "filename": "main.py",
            "code": "import machinepkglineflagfrom time import sleeppkglineflagimport esp32, esppkglineflagfrom engine.engine_template import EngineTemplatepkglineflagfrom wifuxlogger import WifuxLogger as LOGpkglineflagfrom dev.pin.core import CommonCommands as PinCommandspkglineflagfrom etc.config.core import _find_valuepkglineflagpkglineflagconfig_path=\"//app/deepsleep/deepsleepconfig.json\"pkglineflagusername = _find_value('user/username')pkglineflagmachine_name = _find_value('system/machine')pkglineflagpkglineflagclass DeepSleepUsage():pkglineflag    pkglineflag    @staticmethodpkglineflag    def var_usage():pkglineflag        message = LOG.info('\\nUsage:\\n->deepsleep var --name [PIN_NAME] --pin0 [PIN_NUMBER] --pin1 [BACKUP_PIN_NUMBER1] --pin2 [BACKUP_PIN_NUMBER2]')+\"\\n\"+LOG.info(\"Registration must be required to use the machine externally(gpio/button) or with touchpad.\")+\"\\n\"pkglineflag        message += LOG.info(\"--pin0 parameter must be entered, --pin1 and --pin2 parameters are optional.\")+\"\\n\"+LOG.info(\"All pins entered are set for external button or touchpad.\")pkglineflag        return messagepkglineflag    pkglineflag    @staticmethodpkglineflag    def delete_usage():pkglineflag        return LOG.info('Usage -> deepsleep delete [PIN_NAME]')+\"\\n\"+LOG.info('deletes registered pin of deepsleep named [PIN_NAME]')+\"\\n\"+LOG.info('To delete all registered deepsleep pins -> deepsleep delete all')pkglineflag    pkglineflag    @staticmethodpkglineflag    def update_usage():pkglineflag        return LOG.info('Usage -> deepsleep update [PIN_NAME] --[VALUE_TO_CHANGE] [NEW_VALUE]')+\"\\n\"+LOG.info('updates the [VALUE_TO_CHANGE] value of the deepsleep pin named [PIN_NAME] to [NEW_VALUE]')pkglineflag    pkglineflag    @staticmethodpkglineflag    def show_usage():pkglineflag        return LOG.info('Usage -> deepsleep show')+\"\\n\"+LOG.info('shows all registered pins of deepsleep')+\"\\n\"+LOG.info('Usage -> deepsleep show [PARAMETER]:[VALUE_TO_SEARCH_FOR]')+\"\\n\"+LOG.info('shows specific pins of deepsleep')pkglineflag    pkglineflag    @staticmethodpkglineflag    def wake_usage():pkglineflag        message = LOG.info('Usage -> deepsleep wake [PIN_NAME]/[TIME] -[WAKE_REASON]')+\"\\n\"+LOG.info('-[WAKE_REASON] can be -external_button, -touchpad or -timer')+\"\\n\"+LOG.info('The registered pin named [PIN_NAME] must be entered if the machine is wanted to be woken up externally(gpio/button) or with touchpad.')+\"\\n\"pkglineflag        message += LOG.info('the amount of [TIME] the machine will sleep must be entered if the machine is wanted to be woken up with timer.')pkglineflag        return messagepkglineflagpkglineflagdef help(cmds):pkglineflag    command_list = ['var','show','delete','update','wake']pkglineflag    if not len(cmds) > 2:pkglineflag        message = 'Commands: \\n'pkglineflag        for command in command_list:pkglineflag            message += command + \"\\n\"pkglineflag        message += LOG.info('For more information about commands -> deepsleep help [COMMAND]\\n')pkglineflag        message += LOG.info(\"You can just use the 'deepsleep' command to make the machine go into an eternal sleep until you wake it up manually(onboard reset button).\")pkglineflag        return messagepkglineflag    try:pkglineflag        return eval(f'DeepSleepUsage.{cmds[2]}_usage()')pkglineflag    except:pkglineflag        return LOG.error(f'There is no help for \"{cmds[2]}\"!')pkglineflagpkglineflagdef run(cmds):pkglineflag    if not len(cmds)>1:pkglineflag        message = LOG.debug(\"{}'s {} is going to deepsleep. You can wake the machine up by pressing the onboard reset button.\\n\".format(username,machine_name))pkglineflag        message += LOG.info(\"You can use 'deepsleep help' for available commands!\\n\")pkglineflag        message += LOG.info(\"You can use 'deepsleep wake [PIN_NAME]/[TIME] -[WAKE_REASON]' command to remotely control the machine's sleep.\")pkglineflag        print(message)pkglineflag        return machine.deepsleep()pkglineflag    if cmds[1][0] == '_':pkglineflag        return 'OK!'pkglineflag    try:pkglineflag        return eval(f'{cmds[1]}({cmds})')pkglineflag    except Exception as ex:pkglineflag        return LOG.error(\"There is a problem while running deepsleep command!\")+\"\\n\"+LOG.error(str(ex))+\"\\n\"+LOG.error(\"You can use 'deepsleep help' for avaible commands!\")pkglineflag        pkglineflagpkglineflagdef var(cmds):pkglineflag    blueprint={\"pinType\":\"deepsleep\",\"--name\":\"\",\"--pin0\":\"\",\"--pin1\":\"-\",\"--pin2\":\"-\"}pkglineflag    temp = EngineTemplate.parameter_parser(cmds,blueprint)pkglineflag    for key in temp:pkglineflag        if temp[key] == \"\":pkglineflag            return LOG.error('Error while registering pin of deepsleep!')+\"\\n\"+LOG.error('Missing Argument(s)!')pkglineflag    PinCommands(cmds, path=config_path,pin_type=\"deepsleep\").register(blueprint)pkglineflag    return LOG.debug('The new pin of deepsleep named \"{}\" successfully saved:\\n{}'.format(blueprint[\"--name\"],blueprint))pkglineflagpkglineflagdef show(cmds):pkglineflag    return PinCommands(cmds,path=config_path,pin_type=\"deepsleep\").show()pkglineflag        pkglineflagdef delete(cmds):pkglineflag    return PinCommands(cmds, path=config_path, pin_type=\"deepsleep\", pin_name=cmds[2]).delete()pkglineflag        pkglineflagdef update(cmds):pkglineflag    return PinCommands(cmds,path=config_path,pin_type=\"deepsleep\",pin_name=cmds[2]).update()pkglineflagpkglineflagdef wake(cmds):pkglineflag    #esp.osdebug(None)pkglineflag    message = LOG.info('Settings are ok...\\n')pkglineflag    reason = machine.wake_reason()pkglineflag    if reason == 2:pkglineflag        message += LOG.info('Latest wake up reason >> ext0_wake ({})\\n'.format(reason))pkglineflag    elif reason == 3:pkglineflag        message += LOG.info('Latest wake up reason >> ext1_wake ({})\\n'.format(reason))pkglineflag    elif reason == 4:pkglineflag        message += LOG.info('Latest wake up reason >> timer ({})\\n'.format(reason))pkglineflag    elif reason == 5:pkglineflag        message += LOG.info('Latest wake up reason >> touchpad ({})\\n'.format(reason))pkglineflag    try:pkglineflag        if \"-external_button\" in cmds:pkglineflag            payload = PinCommands(cmds, path=config_path,pin_type=\"deepsleep\").returnerload()pkglineflag            pin = PinCommands(cmds,path=config_path,pin_type=\"deepsleep\").get_pin(cmds[0],cmds[2])pkglineflag            if not len(payload) > 0:pkglineflag                return LOG.info(\"No registered pins !\")pkglineflag            else:pkglineflag                pin1 = machine.Pin(int(pin[\"--pin0\"]), machine.Pin.IN)pkglineflag                esp32.wake_on_ext0(pin = pin1, level = esp32.WAKEUP_ANY_HIGH)pkglineflag                if not pin[\"--pin1\"] == \"-\" and not pin[\"--pin2\"] == \"-\":pkglineflag                    pin2 = machine.Pin(int(pin[\"--pin1\"]), machine.Pin.IN)pkglineflag                    pin3 = machine.Pin(int(pin[\"--pin2\"]), machine.Pin.IN)pkglineflag                    esp32.wake_on_ext1(pins = (pin2,pin3, ), level = esp32.WAKEUP_ANY_HIGH)pkglineflag                if not pin[\"--pin1\"] == \"-\" and pin[\"--pin2\"] == \"-\":pkglineflag                    pin2 = machine.Pin(int(pin[\"--pin1\"]), machine.Pin.IN)pkglineflag                    esp32.wake_on_ext1(pins = (pin2, ), level = esp32.WAKEUP_ANY_HIGH)pkglineflag                if pin[\"--pin1\"] == \"-\" and not pin[\"--pin2\"] == \"-\":pkglineflag                    pin3 = machine.Pin(int(pin[\"--pin2\"]), machine.Pin.IN)pkglineflag                    esp32.wake_on_ext1(pins = (pin3, ), level = esp32.WAKEUP_ANY_HIGH)pkglineflag            message += LOG.debug(\"{}'s {} is going to deepsleep\\n\".format(username,machine_name))pkglineflag            print(message)pkglineflag            sleep(3)pkglineflag            return machine.deepsleep()pkglineflag    except Exception as ex:pkglineflag        return LOG.error(ex)pkglineflag    try:pkglineflag        if \"-touchpad\" in cmds:pkglineflag            payload = PinCommands(cmds, path=config_path,pin_type=\"deepsleep\").returnerload()pkglineflag            pin = PinCommands(cmds,path=config_path,pin_type=\"deepsleep\").get_pin(cmds[0],cmds[2])pkglineflag            if not len(payload) > 0:pkglineflag                return LOG.info(\"No registered pins !\")pkglineflag            else:pkglineflag                tch_wake1 = machine.Pin(int(pin[\"--pin0\"]), machine.Pin.IN)pkglineflag                touch1 = machine.TouchPad(tch_wake1)pkglineflag                touch1.config(500)pkglineflag                if not pin[\"--pin1\"] == \"-\":pkglineflag                    tch_wake2 = machine.Pin(int(pin[\"--pin1\"]), machine.Pin.IN)pkglineflag                    touch2 = machine.TouchPad(tch_wake2)pkglineflag                    touch2.config(500)pkglineflag                if not pin[\"--pin2\"] == \"-\":pkglineflag                    tch_wake3 = machine.Pin(int(pin[\"--pin2\"]), machine.Pin.IN)pkglineflag                    touch3 = machine.TouchPad(tch_wake3)pkglineflag                    touch3.config(500)pkglineflag            esp32.wake_on_touch(True)pkglineflag            message += LOG.debug(\"{}'s {} is going to deepsleep\\n\".format(username,machine_name))pkglineflag            print(message)pkglineflag            sleep(3)pkglineflag            return machine.deepsleep()pkglineflag    except Exception as ex:pkglineflag        return LOG.error(ex)pkglineflag    try:pkglineflag        if \"-timer\" in cmds:pkglineflag            m_second = int(cmds[2])*10**3pkglineflag            message += LOG.debug(\"{}'s {} is going to deepsleep\\n\".format(username,machine_name))pkglineflag            print(message)pkglineflag            sleep(3)pkglineflag            return machine.deepsleep(int(m_second))pkglineflag    except Exception as ex:pkglineflag        return LOG.error(ex)"
        }
    ]
}